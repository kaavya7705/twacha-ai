'use client';
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var fileSelector = require('file-selector');
var shared = require('@uploadthing/shared');
var buttonClient = require('./button-client-Cx8_hTCN.cjs');

function UploadDropzone(props) {
    // Cast back to UploadthingComponentProps<TRouter> to get the correct type
    // since the ErrorMessage messes it up otherwise
    const $props = props;
    const { mode = "manual", appendOnPaste = false, cn = shared.defaultClassListMerger } = $props.config ?? {};
    const acRef = React.useRef(new AbortController());
    const [files, setFiles] = React.useState([]);
    const [uploadProgress, setUploadProgress] = React.useState($props.__internal_upload_progress ?? 0);
    const { startUpload, isUploading, routeConfig } = buttonClient.__useUploadThingInternal(shared.resolveMaybeUrlArg($props.url), $props.endpoint, {
        signal: acRef.current.signal,
        headers: $props.headers,
        onClientUploadComplete: (res)=>{
            setFiles([]);
            void $props.onClientUploadComplete?.(res);
            setUploadProgress(0);
        },
        onUploadProgress: (p)=>{
            setUploadProgress(p);
            $props.onUploadProgress?.(p);
        },
        onUploadError: $props.onUploadError,
        onUploadBegin: $props.onUploadBegin,
        onBeforeUploadBegin: $props.onBeforeUploadBegin
    });
    const { fileTypes, multiple } = shared.generatePermittedFileTypes(routeConfig);
    const disabled = !!($props.__internal_dropzone_disabled ?? $props.disabled);
    const state = (()=>{
        const ready = $props.__internal_ready ?? ($props.__internal_state === "ready" || fileTypes.length > 0);
        if ($props.__internal_state) return $props.__internal_state;
        if (disabled) return "disabled";
        if (!ready) return "readying";
        if (ready && !isUploading) return "ready";
        return "uploading";
    })();
    const uploadFiles = React.useCallback((files)=>{
        const input = "input" in $props ? $props.input : undefined;
        startUpload(files, input).catch((e)=>{
            if (e instanceof shared.UploadAbortedError) {
                void $props.onUploadAborted?.();
            } else {
                throw e;
            }
        });
    }, [
        $props,
        startUpload
    ]);
    const onUploadClick = (e)=>{
        if (state === "uploading") {
            e.preventDefault();
            e.stopPropagation();
            acRef.current.abort();
            acRef.current = new AbortController();
            return;
        }
        if (mode === "manual" && files.length > 0) {
            e.preventDefault();
            e.stopPropagation();
            uploadFiles(files);
        }
    };
    const onDrop = React.useCallback((acceptedFiles)=>{
        $props.onDrop?.(acceptedFiles);
        $props.onChange?.(acceptedFiles);
        setFiles(acceptedFiles);
        // If mode is auto, start upload immediately
        if (mode === "auto") uploadFiles(acceptedFiles);
    }, [
        $props,
        mode,
        uploadFiles
    ]);
    const { getRootProps, getInputProps, isDragActive, rootRef } = useDropzone({
        onDrop,
        multiple,
        accept: fileTypes ? shared.generateClientDropzoneAccept(fileTypes) : undefined,
        disabled
    });
    buttonClient.usePaste((event)=>{
        if (!appendOnPaste) return;
        if (document.activeElement !== rootRef.current) return;
        const pastedFiles = shared.getFilesFromClipboardEvent(event);
        if (!pastedFiles?.length) return;
        let filesToUpload = pastedFiles;
        setFiles((prev)=>{
            filesToUpload = [
                ...prev,
                ...pastedFiles
            ];
            $props.onChange?.(filesToUpload);
            return filesToUpload;
        });
        $props.onChange?.(filesToUpload);
        if (mode === "auto") uploadFiles(filesToUpload);
    });
    const styleFieldArg = React.useMemo(()=>({
            ready: state !== "readying",
            isUploading: state === "uploading",
            uploadProgress,
            fileTypes,
            files,
            isDragActive
        }), [
        fileTypes,
        files,
        state,
        uploadProgress,
        isDragActive
    ]);
    const getUploadButtonContents = ()=>{
        const customContent = shared.contentFieldToContent($props.content?.button, styleFieldArg);
        if (customContent) return customContent;
        switch(state){
            case "readying":
                {
                    return "Loading...";
                }
            case "uploading":
                {
                    if (uploadProgress >= 100) return /*#__PURE__*/ jsxRuntime.jsx(buttonClient.Spinner, {});
                    return /*#__PURE__*/ jsxRuntime.jsxs("span", {
                        className: "z-50",
                        children: [
                            /*#__PURE__*/ jsxRuntime.jsxs("span", {
                                className: "block group-hover:hidden",
                                children: [
                                    uploadProgress,
                                    "%"
                                ]
                            }),
                            /*#__PURE__*/ jsxRuntime.jsx(buttonClient.Cancel, {
                                cn: cn,
                                className: "hidden size-4 group-hover:block"
                            })
                        ]
                    });
                }
            case "disabled":
            case "ready":
            default:
                {
                    if (mode === "manual" && files.length > 0) {
                        return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
                    }
                    return `Choose File${multiple ? `(s)` : ``}`;
                }
        }
    };
    return /*#__PURE__*/ jsxRuntime.jsxs("div", {
        className: cn("mt-2 flex flex-col items-center justify-center rounded-lg border border-dashed border-gray-900/25 px-6 py-10 text-center", isDragActive && "bg-blue-600/10", $props.className, shared.styleFieldToClassName($props.appearance?.container, styleFieldArg)),
        ...getRootProps(),
        style: shared.styleFieldToCssObject($props.appearance?.container, styleFieldArg),
        "data-state": state,
        children: [
            shared.contentFieldToContent($props.content?.uploadIcon, styleFieldArg) ?? /*#__PURE__*/ jsxRuntime.jsx("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 20 20",
                className: cn("mx-auto block h-12 w-12 align-middle text-gray-400", shared.styleFieldToClassName($props.appearance?.uploadIcon, styleFieldArg)),
                style: shared.styleFieldToCssObject($props.appearance?.uploadIcon, styleFieldArg),
                "data-ut-element": "upload-icon",
                "data-state": state,
                children: /*#__PURE__*/ jsxRuntime.jsx("path", {
                    fill: "currentColor",
                    fillRule: "evenodd",
                    d: "M5.5 17a4.5 4.5 0 0 1-1.44-8.765a4.5 4.5 0 0 1 8.302-3.046a3.5 3.5 0 0 1 4.504 4.272A4 4 0 0 1 15 17H5.5Zm3.75-2.75a.75.75 0 0 0 1.5 0V9.66l1.95 2.1a.75.75 0 1 0 1.1-1.02l-3.25-3.5a.75.75 0 0 0-1.1 0l-3.25 3.5a.75.75 0 1 0 1.1 1.02l1.95-2.1v4.59Z",
                    clipRule: "evenodd"
                })
            }),
            /*#__PURE__*/ jsxRuntime.jsxs("label", {
                className: cn("relative mt-4 flex w-64 cursor-pointer items-center justify-center text-sm font-semibold leading-6 text-gray-600 focus-within:outline-none focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2 hover:text-blue-500", state === "ready" ? "text-blue-600" : "text-gray-500", shared.styleFieldToClassName($props.appearance?.label, styleFieldArg)),
                style: shared.styleFieldToCssObject($props.appearance?.label, styleFieldArg),
                "data-ut-element": "label",
                "data-state": state,
                children: [
                    /*#__PURE__*/ jsxRuntime.jsx("input", {
                        className: "sr-only",
                        ...getInputProps()
                    }),
                    shared.contentFieldToContent($props.content?.label, styleFieldArg) ?? (state === "ready" ? `Choose ${multiple ? "file(s)" : "a file"} or drag and drop` : `Loading...`)
                ]
            }),
            /*#__PURE__*/ jsxRuntime.jsx("div", {
                className: cn("m-0 h-[1.25rem] text-xs leading-5 text-gray-600", shared.styleFieldToClassName($props.appearance?.allowedContent, styleFieldArg)),
                style: shared.styleFieldToCssObject($props.appearance?.allowedContent, styleFieldArg),
                "data-ut-element": "allowed-content",
                "data-state": state,
                children: shared.contentFieldToContent($props.content?.allowedContent, styleFieldArg) ?? shared.allowedContentTextLabelGenerator(routeConfig)
            }),
            /*#__PURE__*/ jsxRuntime.jsx("button", {
                className: cn("group relative mt-4 flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md border-none text-base text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2", state === "disabled" && "cursor-not-allowed bg-blue-400", state === "readying" && "cursor-not-allowed bg-blue-400", state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${buttonClient.progressWidths[uploadProgress]}`, state === "ready" && "bg-blue-600", "disabled:pointer-events-none", shared.styleFieldToClassName($props.appearance?.button, styleFieldArg)),
                style: shared.styleFieldToCssObject($props.appearance?.button, styleFieldArg),
                onClick: onUploadClick,
                "data-ut-element": "button",
                "data-state": state,
                type: "button",
                disabled: files.length === 0 || state === "disabled",
                children: getUploadButtonContents()
            })
        ]
    });
}
/**
 * A React hook that creates a drag 'n' drop area.
 *
 * ### Example
 *
 * ```tsx
 * function MyDropzone() {
 *   const { getRootProps, getInputProps } = useDropzone({
 *     onDrop: acceptedFiles => {
 *       // do something with the File objects, e.g. upload to some server
 *     }
 *   });
 *
 *   return (
 *     <div {...getRootProps()}>
 *       <input {...getInputProps()} />
 *       <p>Drag and drop some files here, or click to select files</p>
 *     </div>
 *   )
 * }
 * ```
 */ function useDropzone({ accept, disabled = false, maxSize = Number.POSITIVE_INFINITY, minSize = 0, multiple = true, maxFiles = 0, onDrop }) {
    const acceptAttr = React.useMemo(()=>shared.acceptPropAsAcceptAttr(accept), [
        accept
    ]);
    const rootRef = React.useRef(null);
    const inputRef = React.useRef(null);
    const dragTargetsRef = React.useRef([]);
    const [state, dispatch] = React.useReducer(shared.reducer, shared.initialState);
    React.useEffect(()=>{
        // Update file dialog active state when the window is focused on
        const onWindowFocus = ()=>{
            // Execute the timeout only if the file dialog is opened in the browser
            if (state.isFileDialogActive) {
                setTimeout(()=>{
                    if (inputRef.current) {
                        const { files } = inputRef.current;
                        if (!files?.length) {
                            dispatch({
                                type: "closeDialog"
                            });
                        }
                    }
                }, 300);
            }
        };
        window.addEventListener("focus", onWindowFocus, false);
        return ()=>{
            window.removeEventListener("focus", onWindowFocus, false);
        };
    }, [
        state.isFileDialogActive
    ]);
    React.useEffect(()=>{
        const onDocumentDrop = (event)=>{
            // If we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
            if (rootRef.current?.contains(event.target)) return;
            event.preventDefault();
            dragTargetsRef.current = [];
        };
        const onDocumentDragOver = (e)=>e.preventDefault();
        document.addEventListener("dragover", onDocumentDragOver, false);
        document.addEventListener("drop", onDocumentDrop, false);
        return ()=>{
            document.removeEventListener("dragover", onDocumentDragOver);
            document.removeEventListener("drop", onDocumentDrop);
        };
    }, []);
    const onDragEnter = React.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        dragTargetsRef.current = [
            ...dragTargetsRef.current,
            event.target
        ];
        if (shared.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (event.isPropagationStopped()) return;
                const fileCount = files.length;
                const isDragAccept = fileCount > 0 && shared.allFilesAccepted({
                    files: files,
                    accept: acceptAttr,
                    minSize,
                    maxSize,
                    multiple,
                    maxFiles
                });
                const isDragReject = fileCount > 0 && !isDragAccept;
                dispatch({
                    type: "setDraggedFiles",
                    payload: {
                        isDragAccept,
                        isDragReject,
                        isDragActive: true
                    }
                });
            }).catch(shared.noop);
        }
    }, [
        acceptAttr,
        maxFiles,
        maxSize,
        minSize,
        multiple
    ]);
    const onDragOver = React.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        const hasFiles = shared.isEventWithFiles(event);
        if (hasFiles && event.dataTransfer !== null) {
            try {
                event.dataTransfer.dropEffect = "copy";
            } catch  {
                shared.noop();
            }
        }
        return false;
    }, []);
    const onDragLeave = React.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        // Only deactivate once the dropzone and all children have been left
        const targets = dragTargetsRef.current.filter((target)=>rootRef.current?.contains(target));
        // Make sure to remove a target present multiple times only once
        // (Firefox may fire dragenter/dragleave multiple times on the same element)
        const targetIdx = targets.indexOf(event.target);
        if (targetIdx !== -1) targets.splice(targetIdx, 1);
        dragTargetsRef.current = targets;
        if (targets.length > 0) return;
        dispatch({
            type: "setDraggedFiles",
            payload: {
                isDragActive: false,
                isDragAccept: false,
                isDragReject: false
            }
        });
    }, []);
    const setFiles = React.useCallback((files)=>{
        const acceptedFiles = [];
        files.forEach((file)=>{
            const accepted = shared.isFileAccepted(file, acceptAttr);
            const sizeMatch = shared.isValidSize(file, minSize, maxSize);
            if (accepted && sizeMatch) {
                acceptedFiles.push(file);
            }
        });
        if (!shared.isValidQuantity(acceptedFiles, multiple, maxFiles)) {
            acceptedFiles.splice(0);
        }
        dispatch({
            type: "setFiles",
            payload: {
                acceptedFiles
            }
        });
        onDrop(acceptedFiles);
    }, [
        acceptAttr,
        maxFiles,
        maxSize,
        minSize,
        multiple,
        onDrop
    ]);
    const onDropCb = React.useCallback((event)=>{
        event.preventDefault();
        event.persist();
        dragTargetsRef.current = [];
        if (shared.isEventWithFiles(event)) {
            Promise.resolve(fileSelector.fromEvent(event)).then((files)=>{
                if (event.isPropagationStopped()) return;
                setFiles(files);
            }).catch(shared.noop);
        }
        dispatch({
            type: "reset"
        });
    }, [
        setFiles
    ]);
    const openFileDialog = React.useCallback(()=>{
        if (inputRef.current) {
            dispatch({
                type: "openDialog"
            });
            inputRef.current.value = "";
            inputRef.current.click();
        }
    }, []);
    // Cb to open the file dialog when SPACE/ENTER occurs on the dropzone
    const onKeyDown = React.useCallback((event)=>{
        // Ignore keyboard events bubbling up the DOM tree
        if (!rootRef.current?.isEqualNode(event.target)) return;
        if (shared.isEnterOrSpace(event)) {
            event.preventDefault();
            openFileDialog();
        }
    }, [
        openFileDialog
    ]);
    const onInputElementClick = React.useCallback((e)=>{
        e.stopPropagation();
        if (state.isFileDialogActive) {
            e.preventDefault();
        }
    }, [
        state.isFileDialogActive
    ]);
    // Update focus state for the dropzone
    const onFocus = React.useCallback(()=>dispatch({
            type: "focus"
        }), []);
    const onBlur = React.useCallback(()=>dispatch({
            type: "blur"
        }), []);
    const onClick = React.useCallback(()=>{
        // In IE11/Edge the file-browser dialog is blocking, therefore,
        // use setTimeout() to ensure React can handle state changes
        shared.isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
    }, [
        openFileDialog
    ]);
    const getRootProps = React.useMemo(()=>()=>({
                ref: rootRef,
                role: "presentation",
                ...!disabled ? {
                    tabIndex: 0,
                    onKeyDown,
                    onFocus,
                    onBlur,
                    onClick,
                    onDragEnter,
                    onDragOver,
                    onDragLeave,
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    onDrop: onDropCb
                } : {}
            }), [
        disabled,
        onBlur,
        onClick,
        onDragEnter,
        onDragLeave,
        onDragOver,
        onDropCb,
        onFocus,
        onKeyDown
    ]);
    const getInputProps = React.useMemo(()=>()=>({
                ref: inputRef,
                type: "file",
                style: {
                    display: "none"
                },
                accept: acceptAttr,
                multiple,
                tabIndex: -1,
                ...!disabled ? {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                    onChange: onDropCb,
                    onClick: onInputElementClick
                } : {}
            }), [
        acceptAttr,
        multiple,
        onDropCb,
        onInputElementClick,
        disabled
    ]);
    return {
        ...state,
        getRootProps,
        getInputProps,
        rootRef
    };
}

exports.UploadDropzone = UploadDropzone;
exports.useDropzone = useDropzone;
