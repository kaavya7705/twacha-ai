'use client';
import { jsx, jsxs } from 'react/jsx-runtime';
import React, { useRef, useReducer, useEffect, useState, useCallback, useMemo } from 'react';
import { safeParseJSON, warnIfInvalidPeerDependency, resolveMaybeUrlArg, unwrap, UploadAbortedError, UploadThingError, INTERNAL_DO_NOT_USE__fatalClientError, generatePermittedFileTypes, generateMimeTypes, styleFieldToClassName, styleFieldToCssObject, defaultClassListMerger, contentFieldToContent, allowedContentTextLabelGenerator, getFilesFromClipboardEvent } from '@uploadthing/shared';
import { version, genUploader } from 'uploadthing/client';

var peerDependencies = {
	next: "*",
	react: "^17.0.2 || ^18.0.0 || ^19.0.0",
	uploadthing: "^7.2.0"
};

// Ripped from https://github.com/scottrippey/react-use-event-hook
const noop = ()=>void 0;
/**
 * Suppress the warning when using useLayoutEffect with SSR. (https://reactjs.org/link/uselayouteffect-ssr)
 * Make use of useInsertionEffect if available.
 */ const useInsertionEffect = typeof window !== "undefined" ? React.useInsertionEffect || React.useLayoutEffect : noop;
/**
 * Similar to useCallback, with a few subtle differences:
 * - The returned function is a stable reference, and will always be the same between renders
 * - No dependency lists required
 * - Properties or state accessed within the callback will always be "current"
 */ function useEvent(callback) {
    // Keep track of the latest callback:
    const latestRef = React.useRef(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    useEvent_shouldNotBeInvokedBeforeMount);
    useInsertionEffect(()=>{
        latestRef.current = callback;
    }, [
        callback
    ]);
    // Create a stable callback that always calls the latest callback:
    // using useRef instead of useCallback avoids creating and empty array on every render
    const stableRef = React.useRef();
    if (!stableRef.current) {
        stableRef.current = function() {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, prefer-rest-params, @typescript-eslint/no-unsafe-argument
            return latestRef.current.apply(this, arguments);
        };
    }
    return stableRef.current;
}
/**
 * Render methods should be pure, especially when concurrency is used,
 * so we will throw this error if the callback is called while rendering.
 */ function useEvent_shouldNotBeInvokedBeforeMount() {
    throw new Error("INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted.");
}

// Ripped from https://usehooks-ts.com/react-hook/use-fetch
function useFetch(url, options) {
    const cache = useRef({});
    // Used to prevent state update if the component is unmounted
    const cancelRequest = useRef(false);
    const initialState = {
        error: undefined,
        data: undefined
    };
    // Keep state logic separated
    const fetchReducer = (state, action)=>{
        switch(action.type){
            case "loading":
                return {
                    ...initialState
                };
            case "fetched":
                return {
                    ...initialState,
                    data: action.payload
                };
            case "error":
                return {
                    ...initialState,
                    error: action.payload
                };
            default:
                return state;
        }
    };
    const [state, dispatch] = useReducer(fetchReducer, initialState);
    useEffect(()=>{
        // Do nothing if the url is not given
        if (!url) return;
        cancelRequest.current = false;
        const fetchData = async ()=>{
            dispatch({
                type: "loading"
            });
            // If a cache exists for this url, return it
            if (cache.current[url]) {
                dispatch({
                    type: "fetched",
                    payload: cache.current[url]
                });
                return;
            }
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                const dataOrError = await safeParseJSON(response);
                if (dataOrError instanceof Error) {
                    throw dataOrError;
                }
                cache.current[url] = dataOrError;
                if (cancelRequest.current) return;
                dispatch({
                    type: "fetched",
                    payload: dataOrError
                });
            } catch (error) {
                if (cancelRequest.current) return;
                dispatch({
                    type: "error",
                    payload: error
                });
            }
        };
        void fetchData();
        // Use the cleanup function for avoiding a possibly...
        // ...state update after the component was unmounted
        return ()=>{
            cancelRequest.current = true;
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        url
    ]);
    return state;
}

const useRouteConfig = (url, endpoint)=>{
    const maybeServerData = globalThis.__UPLOADTHING;
    const { data } = useFetch(// Don't fetch if we already have the data
    maybeServerData ? undefined : url.href);
    return (maybeServerData ?? data)?.find((x)=>x.slug === endpoint)?.config;
};
/**
 * @internal - This is an internal function. Use `generateReactHelpers` instead.
 * The actual hook we export for public usage is generated from `generateReactHelpers`
 * which has the URL and FileRouter generic pre-bound.
 */ function __useUploadThingInternal(url, endpoint, opts) {
    const { uploadFiles, routeRegistry } = genUploader({
        url,
        package: "@uploadthing/react"
    });
    const [isUploading, setUploading] = useState(false);
    const uploadProgress = useRef(0);
    const fileProgress = useRef(new Map());
    const startUpload = useEvent(async (...args)=>{
        const files = await opts?.onBeforeUploadBegin?.(args[0]) ?? args[0];
        const input = args[1];
        setUploading(true);
        files.forEach((f)=>fileProgress.current.set(f, 0));
        opts?.onUploadProgress?.(0);
        try {
            const res = await uploadFiles(endpoint, {
                signal: opts?.signal,
                headers: opts?.headers,
                files,
                onUploadProgress: (progress)=>{
                    if (!opts?.onUploadProgress) return;
                    fileProgress.current.set(progress.file, progress.progress);
                    let sum = 0;
                    fileProgress.current.forEach((p)=>{
                        sum += p;
                    });
                    const averageProgress = Math.floor(sum / fileProgress.current.size / 10) * 10;
                    if (averageProgress !== uploadProgress.current) {
                        opts?.onUploadProgress?.(averageProgress);
                        uploadProgress.current = averageProgress;
                    }
                },
                onUploadBegin ({ file }) {
                    if (!opts?.onUploadBegin) return;
                    opts.onUploadBegin(file);
                },
                // @ts-expect-error - input may not be defined on the type
                input
            });
            await opts?.onClientUploadComplete?.(res);
            return res;
        } catch (e) {
            /**
       * This is the only way to introduce this as a non-breaking change
       * TODO: Consider refactoring API in the next major version
       */ if (e instanceof UploadAbortedError) throw e;
            let error;
            if (e instanceof UploadThingError) {
                error = e;
            } else {
                error = INTERNAL_DO_NOT_USE__fatalClientError(e);
                console.error("Something went wrong. Please contact UploadThing and provide the following cause:", error.cause instanceof Error ? error.cause.toString() : error.cause);
            }
            await opts?.onUploadError?.(error);
        } finally{
            setUploading(false);
            fileProgress.current = new Map();
            uploadProgress.current = 0;
        }
    });
    const _endpoint = unwrap(endpoint, routeRegistry);
    const routeConfig = useRouteConfig(url, _endpoint);
    return {
        startUpload,
        isUploading,
        routeConfig
    };
}
const generateReactHelpers = (initOpts)=>{
    warnIfInvalidPeerDependency("@uploadthing/react", peerDependencies.uploadthing, version);
    const url = resolveMaybeUrlArg(initOpts?.url);
    const clientHelpers = genUploader({
        url,
        package: "@uploadthing/react"
    });
    function useUploadThing(endpoint, opts) {
        return __useUploadThingInternal(url, endpoint, opts);
    }
    function getRouteConfig(slug) {
        const maybeServerData = globalThis.__UPLOADTHING;
        const endpoint = unwrap(slug, clientHelpers.routeRegistry);
        const config = maybeServerData?.find((x)=>x.slug === endpoint)?.config;
        if (!config) {
            throw new Error(`No config found for endpoint "${endpoint.toString()}". Please make sure to use the NextSSRPlugin in your Next.js app.`);
        }
        return config;
    }
    return {
        useUploadThing,
        ...clientHelpers,
        /**
     * Get the config for a given endpoint outside of React context.
     * @remarks Can only be used if the NextSSRPlugin is used in the app.
     */ getRouteConfig
    };
};

const usePaste = (callback)=>{
    const stableCallback = useEvent(callback);
    useEffect(()=>{
        window.addEventListener("paste", stableCallback);
        return ()=>{
            window.removeEventListener("paste", stableCallback);
        };
    }, [
        stableCallback
    ]);
};

function Spinner() {
    return /*#__PURE__*/ jsx("svg", {
        className: "z-10 block h-5 w-5 animate-spin align-middle text-white",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 576 512",
        children: /*#__PURE__*/ jsx("path", {
            fill: "currentColor",
            d: "M256 32C256 14.33 270.3 0 288 0C429.4 0 544 114.6 544 256C544 302.6 531.5 346.4 509.7 384C500.9 399.3 481.3 404.6 465.1 395.7C450.7 386.9 445.5 367.3 454.3 351.1C470.6 323.8 480 291 480 255.1C480 149.1 394 63.1 288 63.1C270.3 63.1 256 49.67 256 31.1V32z"
        })
    });
}
function Cancel({ className, cn, ...props }) {
    return /*#__PURE__*/ jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        className: cn("fill-none stroke-current stroke-2", className),
        ...props,
        children: [
            /*#__PURE__*/ jsx("circle", {
                cx: "12",
                cy: "12",
                r: "10"
            }),
            /*#__PURE__*/ jsx("path", {
                d: "m4.9 4.9 14.2 14.2"
            })
        ]
    });
}
const progressWidths = {
    0: "after:w-0",
    10: "after:w-[10%]",
    20: "after:w-[20%]",
    30: "after:w-[30%]",
    40: "after:w-[40%]",
    50: "after:w-[50%]",
    60: "after:w-[60%]",
    70: "after:w-[70%]",
    80: "after:w-[80%]",
    90: "after:w-[90%]",
    100: "after:w-[100%]"
};

/**
 * @remarks It is not recommended using this directly as it requires manually binding generics. Instead, use `createUploadButton`.
 * @example
 * <UploadButton<OurFileRouter, "someEndpoint">
 *   endpoint="someEndpoint"
 *   onUploadComplete={(res) => console.log(res)}
 *   onUploadError={(err) => console.log(err)}
 * />
 */ function UploadButton(props) {
    // Cast back to UploadthingComponentProps<TRouter> to get the correct type
    // since the ErrorMessage messes it up otherwise
    const $props = props;
    const { mode = "auto", appendOnPaste = false, cn = defaultClassListMerger } = $props.config ?? {};
    const acRef = useRef(new AbortController());
    const fileInputRef = useRef(null);
    const [uploadProgress, setUploadProgress] = useState($props.__internal_upload_progress ?? 0);
    const [files, setFiles] = useState([]);
    const { startUpload, isUploading, routeConfig } = __useUploadThingInternal(resolveMaybeUrlArg($props.url), $props.endpoint, {
        signal: acRef.current.signal,
        headers: $props.headers,
        onClientUploadComplete: (res)=>{
            if (fileInputRef.current) {
                fileInputRef.current.value = "";
            }
            setFiles([]);
            void $props.onClientUploadComplete?.(res);
            setUploadProgress(0);
        },
        onUploadProgress: (p)=>{
            setUploadProgress(p);
            $props.onUploadProgress?.(p);
        },
        onUploadError: $props.onUploadError,
        onUploadBegin: $props.onUploadBegin,
        onBeforeUploadBegin: $props.onBeforeUploadBegin
    });
    const { fileTypes, multiple } = generatePermittedFileTypes(routeConfig);
    const disabled = !!($props.__internal_button_disabled ?? $props.disabled);
    const state = (()=>{
        const ready = $props.__internal_state === "ready" || fileTypes.length > 0;
        if ($props.__internal_state) return $props.__internal_state;
        if (disabled) return "disabled";
        if (!ready) return "readying";
        if (ready && !isUploading) return "ready";
        return "uploading";
    })();
    const uploadFiles = useCallback((files)=>{
        const input = "input" in $props ? $props.input : undefined;
        startUpload(files, input).catch((e)=>{
            if (e instanceof UploadAbortedError) {
                void $props.onUploadAborted?.();
            } else {
                throw e;
            }
        });
    }, [
        $props,
        startUpload
    ]);
    const onUploadClick = (e)=>{
        if (state === "uploading") {
            e.preventDefault();
            e.stopPropagation();
            acRef.current.abort();
            acRef.current = new AbortController();
            return;
        }
        if (mode === "manual" && files.length > 0) {
            e.preventDefault();
            e.stopPropagation();
            uploadFiles(files);
        }
    };
    const inputProps = useMemo(()=>({
            type: "file",
            ref: fileInputRef,
            multiple,
            accept: generateMimeTypes(fileTypes).join(", "),
            onChange: (e)=>{
                if (!e.target.files) return;
                const selectedFiles = Array.from(e.target.files);
                $props.onChange?.(selectedFiles);
                if (mode === "manual") {
                    setFiles(selectedFiles);
                    return;
                }
                uploadFiles(selectedFiles);
            },
            disabled,
            tabIndex: disabled ? -1 : 0
        }), [
        $props,
        disabled,
        fileTypes,
        mode,
        multiple,
        uploadFiles
    ]);
    usePaste((event)=>{
        if (!appendOnPaste) return;
        if (document.activeElement !== fileInputRef.current) return;
        const pastedFiles = getFilesFromClipboardEvent(event);
        if (!pastedFiles) return;
        let filesToUpload = pastedFiles;
        setFiles((prev)=>{
            filesToUpload = [
                ...prev,
                ...pastedFiles
            ];
            $props.onChange?.(filesToUpload);
            return filesToUpload;
        });
        if (mode === "auto") uploadFiles(files);
    });
    const styleFieldArg = useMemo(()=>({
            ready: state !== "readying",
            isUploading: state === "uploading",
            uploadProgress,
            fileTypes,
            files
        }), [
        fileTypes,
        files,
        state,
        uploadProgress
    ]);
    const renderButton = ()=>{
        const customContent = contentFieldToContent($props.content?.button, styleFieldArg);
        if (customContent) return customContent;
        switch(state){
            case "readying":
                {
                    return "Loading...";
                }
            case "uploading":
                {
                    if (uploadProgress >= 100) return /*#__PURE__*/ jsx(Spinner, {});
                    return /*#__PURE__*/ jsxs("span", {
                        className: "z-50",
                        children: [
                            /*#__PURE__*/ jsxs("span", {
                                className: "block group-hover:hidden",
                                children: [
                                    uploadProgress,
                                    "%"
                                ]
                            }),
                            /*#__PURE__*/ jsx(Cancel, {
                                cn: cn,
                                className: "hidden size-4 group-hover:block"
                            })
                        ]
                    });
                }
            case "disabled":
            case "ready":
            default:
                {
                    if (mode === "manual" && files.length > 0) {
                        return `Upload ${files.length} file${files.length === 1 ? "" : "s"}`;
                    }
                    return `Choose File${inputProps.multiple ? `(s)` : ``}`;
                }
        }
    };
    const renderClearButton = ()=>/*#__PURE__*/ jsx("button", {
            onClick: ()=>{
                setFiles([]);
                if (fileInputRef.current) {
                    fileInputRef.current.value = "";
                }
                $props.onChange?.([]);
            },
            className: cn("h-[1.25rem] cursor-pointer rounded border-none bg-transparent text-gray-500 transition-colors hover:bg-slate-200 hover:text-gray-600", styleFieldToClassName($props.appearance?.clearBtn, styleFieldArg)),
            style: styleFieldToCssObject($props.appearance?.clearBtn, styleFieldArg),
            "data-state": state,
            "data-ut-element": "clear-btn",
            children: contentFieldToContent($props.content?.clearBtn, styleFieldArg) ?? "Clear"
        });
    const renderAllowedContent = ()=>/*#__PURE__*/ jsx("div", {
            className: cn("h-[1.25rem] text-xs leading-5 text-gray-600", styleFieldToClassName($props.appearance?.allowedContent, styleFieldArg)),
            style: styleFieldToCssObject($props.appearance?.allowedContent, styleFieldArg),
            "data-state": state,
            "data-ut-element": "allowed-content",
            children: contentFieldToContent($props.content?.allowedContent, styleFieldArg) ?? allowedContentTextLabelGenerator(routeConfig)
        });
    return /*#__PURE__*/ jsxs("div", {
        className: cn("flex flex-col items-center justify-center gap-1", $props.className, styleFieldToClassName($props.appearance?.container, styleFieldArg)),
        style: styleFieldToCssObject($props.appearance?.container, styleFieldArg),
        "data-state": state,
        children: [
            /*#__PURE__*/ jsxs("label", {
                className: cn("group relative flex h-10 w-36 cursor-pointer items-center justify-center overflow-hidden rounded-md text-white after:transition-[width] after:duration-500 focus-within:ring-2 focus-within:ring-blue-600 focus-within:ring-offset-2", state === "disabled" && "cursor-not-allowed bg-blue-400", state === "readying" && "cursor-not-allowed bg-blue-400", state === "uploading" && `bg-blue-400 after:absolute after:left-0 after:h-full after:bg-blue-600 after:content-[''] ${progressWidths[uploadProgress]}`, state === "ready" && "bg-blue-600", styleFieldToClassName($props.appearance?.button, styleFieldArg)),
                style: styleFieldToCssObject($props.appearance?.button, styleFieldArg),
                "data-state": state,
                "data-ut-element": "button",
                onClick: onUploadClick,
                children: [
                    /*#__PURE__*/ jsx("input", {
                        ...inputProps,
                        className: "sr-only"
                    }),
                    renderButton()
                ]
            }),
            mode === "manual" && files.length > 0 ? renderClearButton() : renderAllowedContent()
        ]
    });
}

export { Cancel as C, Spinner as S, UploadButton as U, __useUploadThingInternal as _, peerDependencies as a, generateReactHelpers as g, progressWidths as p, usePaste as u };
